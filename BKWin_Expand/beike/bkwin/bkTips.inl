// This file was generated by WTL subclass control wizard 
// CustomTips.cpp : Implementation of CBkTips

#define BKTIPS_TIMER_HIDE 0
#define BKTIPS_TIMER_TRACEMOUSE 1

#define BKTIPS_DRAWTEXT_STYLE  DT_LEFT|DT_WORDBREAK |DT_EDITCONTROL|DT_NOFULLWIDTHCHARBREAK


class CClientRect : public CRect
{
public:
    CClientRect(HWND hWnd)
    {
        ::GetClientRect(hWnd, this);
    }
};


static TCHAR szTipProp[] = _T("TipProp");


// CBkTips
inline CBkTips::CBkTips()
    : m_nDelayTime(-1)
    , m_nStyle(eCTTS_Style_border|eCTTS_Style_arrow)
    , m_nTextWidth(200)
    , m_enumPosition(eCTTS_POS_Top)
    , m_enumAlign(eCTTS_Align_Normal)
    , m_nMarginWidth(12)
    , m_nMarginHeight(6)
    , m_clrTextColor(RGB(0x9B, 0x69, 0x12))
    , m_sizeArrow(10, 10)
{
    m_brBorderOut = CreateSolidBrush(m_clrBorderOut);
    m_brBorderIn = CreateSolidBrush(m_clrBorderIn);
    m_rgn.CreateRectRgn(0, 0, 0, 0);	
}

inline CBkTips::~CBkTips()
{
	m_brBorderIn.DeleteObject();
	m_brBorderOut.DeleteObject();
	m_rgn.DeleteObject();
}

inline void CBkTips::CheckCreateDefFont()
{
    if (m_font.m_hFont  ==  NULL)
    {
        //         LOGFONT lf;
        //         CFontHandle(CWindow(hParent).GetFont()).GetLogFont(lf);
        //         m_font.CreateFontIndirect(&lf);
        SetTextStyle(m_clrTextColor, 90, L"宋体");
    }
}

inline void CBkTips::SetTextStyle(COLORREF clr, int nPointSize, LPCWSTR szFaceName)
{
    if (m_font.m_hFont  !=  NULL)
        m_font.DeleteObject();
    m_clrTextColor = clr;
    m_font.CreatePointFont(nPointSize, szFaceName, NULL);
}

inline void CBkTips::SetMargins(UINT nWidth, UINT nHeight)
{
    m_nMarginWidth = nWidth;
    m_nMarginHeight = nHeight;
}

inline void CBkTips::SetDelayTime(int nDelayTimes)
{
    m_nDelayTime = nDelayTimes;
}

inline UINT CBkTips::GetStyle()
{
    return m_nStyle;
}

inline void CBkTips::SetBGImage(LPCWSTR szPNGPathName, LPCWSTR szArrowPathName)
{
    ATLASSERT(szPNGPathName  !=  NULL);
    ATLASSERT(szArrowPathName  !=  NULL);
    m_strBGPath = szPNGPathName;
    m_strArrowPath = szArrowPathName;
}

inline void CBkTips::SetWidth(int nTipsWidth)
{
    m_nTextWidth = nTipsWidth;
}

inline void CBkTips::HideTips()
{
    if (IsWindow())
    {
        KillTimer(BKTIPS_TIMER_HIDE);
        KillTimer(BKTIPS_TIMER_TRACEMOUSE);
        DestroyWindow();
    }
    if (m_hParent != NULL && m_ProcOld != NULL)
    {
        SetProp(m_hParent, szTipProp, NULL);
        ::SetWindowLong(m_hParent, GWL_WNDPROC, (LONG)(LONG_PTR)m_ProcOld);
    }
}

inline void CBkTips::SetPosAlign(CustomTipsPos position, CustomTipsAlign align)
{
    m_enumPosition =  position;
    m_enumAlign = align;
}

inline void CBkTips::ModifyTipsStyle(UINT uiAddStyle, UINT uiRemoveStyle)
{
    m_nStyle = (m_nStyle &~ uiRemoveStyle) | uiAddStyle;
}

inline bool CBkTips::ShowTips(HWND hParent, POINT pt, LPCWSTR szText)
{
    using namespace Gdiplus;
    if (IsWindow()) 
        HideTips();

    m_strText = szText;
    fGetWndRectType GetWndRect;

    CheckCreateDefFont();
    HWND hFocus = ::GetFocus();
    ::ClientToScreen(hParent, &pt);

    Create(hParent, CRect(0, 0, 0, 0), NULL, WS_POPUP);

    CClientDC dc(m_hWnd);
    CSize wndSize;
    CalTextSize(dc, szText, &wndSize);//计算出文字所占用的空间
    wndSize.cy += m_nMarginHeight*2;
    wndSize.cx += m_nMarginWidth*2;

    //计算出各个位置参数而生成的point, size, rgn
    CSize destSize;
    CPoint destPoint;
    CRgn destRgn;
    GetWndRect = PolicyWndRect();
    (this->*GetWndRect)(wndSize, pt, &destSize, &destPoint, &destRgn);
    m_rgn.CombineRgn(destRgn, NULL, RGN_COPY);

    //设置位置
    SetWindowPos(NULL, destPoint.x, destPoint.y, destSize.cx, destSize.cy, SWP_HIDEWINDOW);

    //设置异形窗口
    SetWindowRgn(destRgn, TRUE);

    //显示窗口
    ShowWindow(SW_SHOW);

    //DrawText(dc);
    ::SetFocus(hFocus);

    if (m_nDelayTime>0)
        SetTimer(0, m_nDelayTime);

    m_hParent = hParent;
    SetProp(hParent, szTipProp, (HANDLE)this);
    m_ProcOld = (WNDPROC)(LONG_PTR)::SetWindowLong(hParent, GWL_WNDPROC, (LONG)(LONG_PTR)TipParentProc);

    return true;
}

inline BOOL CBkTips::PtInWindow()
{
    POINT curPoint;
    GetCursorPos(&curPoint);
    ::ScreenToClient(m_hWnd, &curPoint);
    CClientRect rc(m_hWnd);
    return rc.PtInRect(curPoint);
}

inline LRESULT CBkTips::OnTimer(UINT_PTR id)
{
    if (BKTIPS_TIMER_HIDE  ==  id)
    {
        KillTimer(BKTIPS_TIMER_HIDE);

        if (TRUE == PtInWindow())
        {
            SetTimer(BKTIPS_TIMER_TRACEMOUSE, 50);//50毫秒检查一次
            return 0;
        }
        HideTips();
    }
    else if (BKTIPS_TIMER_TRACEMOUSE  ==  id)
    {
        if (FALSE == PtInWindow())
            HideTips();

    }
    return 0l;
}

inline LRESULT CBkTips::OnLButtonDown(UINT Flags, CPoint Pt)
{
    HideTips();
    return 0l;
}

inline void CBkTips::CalTextSize(CDC& dc, LPCWSTR szText, CSize* pOutSize)
{
    CFont oldFont = dc.SelectFont(m_font);
    GetTextExtentPoint(dc, szText, (int)wcslen(szText), pOutSize);
    if (m_nTextWidth>0)//多行模式
    {
        pOutSize->cy =  dc.DrawText(szText, (int)wcslen(szText), CRect(m_nMarginWidth, m_nMarginHeight, m_nMarginWidth + m_nTextWidth, cs_nMaxHeight), BKTIPS_DRAWTEXT_STYLE|DT_CALCRECT);
        if (m_nTextWidth<pOutSize->cx)
            pOutSize->cx = m_nTextWidth;
    }
    dc.SelectFont(oldFont);
}

inline void CBkTips::DrawText(CDC & dc, CRect &rc, COLORREF clr)
{
    dc.SetTextColor(clr);
    if (m_nTextWidth>0)
    {
        dc.DrawText(m_strText, m_strText.GetLength(), rc, BKTIPS_DRAWTEXT_STYLE);
    } else {
        dc.DrawText(m_strText, m_strText.GetLength(), rc, DT_LEFT|DT_SINGLELINE|DT_NOCLIP);
    }
}

inline void CBkTips::DrawBgAndText(CDC & dc)
{
    using namespace Gdiplus;

    CFont oldFont = dc.SelectFont(m_font);
    dc.SetBkMode(TRANSPARENT);
    dc.SetTextColor(m_clrTextColor);

    CClientRect rc(m_hWnd);

    if (m_strBGPath.GetLength()>0)
    {
        Graphics graphics(dc.m_hDC);
        Image image(m_strBGPath, FALSE);
        Rect rcDest(0, 0, rc.Width(), rc.Height());
        ImageAttributes ImgAtt;
        ImgAtt.SetWrapMode(WrapModeTileFlipXY);
        graphics.DrawImage(&image, rcDest, 0, 0, image.GetWidth(), image.GetHeight(), 
            UnitPixel, &ImgAtt);
    }

    CRect rcDraw(m_nMarginWidth, m_nMarginHeight, m_nMarginWidth + m_nTextWidth, cs_nMaxHeight);
    rcDraw.OffsetRect(m_ptTextStart);

    CRect rcDrawWhite(rcDraw);
    rcDrawWhite.OffsetRect(1, 1);


    DrawText(dc, rcDrawWhite, RGB(255, 255, 255));
    DrawText(dc, rcDraw, m_clrTextColor);


    dc.SelectFont(oldFont);
    if (eCTTS_Style_border == (m_nStyle & eCTTS_Style_border))
    {
        CRgn rgnIn;
        InflateRgn(m_rgn, rgnIn);
        dc.FrameRgn(rgnIn, m_brBorderIn, 1, 1);
        dc.FrameRgn(m_rgn, m_brBorderOut, 1, 1);
    }
}

inline void CBkTips::SetBorderColor(COLORREF clrOut, COLORREF clrIn)
{
    if (m_brBorderOut.m_hBrush != NULL)
        m_brBorderOut.DeleteObject();
    m_brBorderOut.CreateSolidBrush(clrOut);

    if (m_brBorderIn.m_hBrush != NULL)
        m_brBorderIn.DeleteObject();
    m_brBorderIn.CreateSolidBrush(clrIn);
}

inline LRESULT CBkTips::OnPaint(HDC hdc)
{
    CPaintDC dc(m_hWnd);
    DrawBgAndText(dc);
    return 0;
}

inline CBkTips::fGetWndRectType CBkTips::PolicyWndRect()
{
    switch(m_enumPosition)
    {
    case  eCTTS_POS_Left:
        return &CBkTips::GetWndRectLeft;
    case  eCTTS_POS_Right:
        return &CBkTips::GetWndRectRight;
    case  eCTTS_POS_Bottom:
        return &CBkTips::GetWndRectBottom;
    case  eCTTS_POS_Top:
        return &CBkTips::GetWndRectTop;
    }
    ATLASSERT(0);
    return NULL;
}

inline void CBkTips::GetWndRectTop(const SIZE & srcSize, const POINT & srcPoint, CSize * pOutSize, CPoint * pOutPoint, CRgn * pOutRgn)
{
    CRgn rgnArrow;
    CRect rcArrow;
    GetArrowRgn(eCTTS_POS_Top, &rgnArrow);
    rgnArrow.GetRgnBox(&rcArrow);

    //SIZE
    pOutSize->cy = rcArrow.Height() + srcSize.cy;
    pOutSize->cx = srcSize.cx;

    //POINT
    if (eCTTS_Align_Reverse  ==  m_enumAlign)
        pOutPoint->x = srcPoint.x - pOutSize->cx;
    else
        pOutPoint->x = srcPoint.x;

    pOutPoint->y = srcPoint.y-pOutSize->cy;

    m_ptTextStart.x = 0;
    m_ptTextStart.y = 0;


    //REGION
    pOutRgn->CreateRoundRectRgn(0, 0, srcSize.cx, srcSize.cy, cs_nRoundRect, cs_nRoundRect);
    if (eCTTS_Align_Reverse  ==  m_enumAlign)
        rgnArrow.OffsetRgn(srcSize.cx - cs_nArrowPos - rcArrow.Width(), srcSize.cy - cs_nAdditionLen);
    else
        rgnArrow.OffsetRgn(cs_nArrowPos, srcSize.cy-cs_nAdditionLen);
    pOutRgn->CombineRgn(*pOutRgn, rgnArrow, RGN_OR);
}


inline void CBkTips::GetWndRectBottom(const SIZE & srcSize, const POINT & srcPoint, CSize * pOutSize, CPoint * pOutPoint, CRgn * pOutRgn)
{
    CRgn rgnArrow;
    CRect rcArrow;
    GetArrowRgn(eCTTS_POS_Bottom, &rgnArrow);
    rgnArrow.GetRgnBox(&rcArrow);

    //SIZE
    pOutSize->cy = rcArrow.Height() + srcSize.cy;
    pOutSize->cx = srcSize.cx;

    //POINT
    if (eCTTS_Align_Reverse == m_enumAlign)
        pOutPoint->x = srcPoint.x-pOutSize->cx;
    else
        pOutPoint->x = srcPoint.x;

    pOutPoint->y = srcPoint.y;

    m_ptTextStart.x = 0;
    m_ptTextStart.y = rcArrow.Height()-cs_nAdditionLen;

    //REGION
    pOutRgn->CreateRoundRectRgn(0, 0, srcSize.cx, srcSize.cy + cs_nAdditionLen, cs_nRoundRect, cs_nRoundRect);
    pOutRgn->OffsetRgn(0, rcArrow.Height()-cs_nAdditionLen);

    if (eCTTS_Align_Reverse == m_enumAlign)
        rgnArrow.OffsetRgn(srcSize.cx-cs_nArrowPos-rcArrow.Width(), 0);
    else
        rgnArrow.OffsetRgn(cs_nArrowPos, 0);
    pOutRgn->CombineRgn(*pOutRgn, rgnArrow, RGN_OR);
}

inline void CBkTips::GetWndRectRight(const SIZE & srcSize, const POINT & srcPoint, CSize * pOutSize, CPoint * pOutPoint, CRgn * pOutRgn)
{
    CRgn rgnArrow;
    CRect rcArrow;
    GetArrowRgn(eCTTS_POS_Right, &rgnArrow);
    rgnArrow.GetRgnBox(&rcArrow);

    //SIZE
    pOutSize->cy = srcSize.cy;
    pOutSize->cx = rcArrow.Width() + srcSize.cx;

    //POINT
    if (eCTTS_Align_Reverse == m_enumAlign)
        pOutPoint->y = srcPoint.y-pOutSize->cy;
    else
        pOutPoint->y = srcPoint.y;

    pOutPoint->x = srcPoint.x;


    m_ptTextStart.x = rcArrow.Width();
    m_ptTextStart.y = 0;

    //REGION
    pOutRgn->CreateRoundRectRgn(0, 0, srcSize.cx + cs_nAdditionLen, srcSize.cy, cs_nRoundRect, cs_nRoundRect);
    pOutRgn->OffsetRgn(rcArrow.Width()-cs_nAdditionLen, 0);


    if (eCTTS_Align_Reverse == m_enumAlign)
        rgnArrow.OffsetRgn(0, srcSize.cy-cs_nArrowPos-rcArrow.Height());
    else
        rgnArrow.OffsetRgn(0, cs_nArrowPos);
    pOutRgn->CombineRgn(*pOutRgn, rgnArrow, RGN_OR);
}

inline void CBkTips::GetWndRectLeft(const SIZE & srcSize, const POINT & srcPoint, CSize * pOutSize, CPoint * pOutPoint, CRgn * pOutRgn)
{
    CRgn rgnArrow;
    CRect rcArrow;
    GetArrowRgn(eCTTS_POS_Left, &rgnArrow);
    rgnArrow.GetRgnBox(&rcArrow);

    //SIZE
    pOutSize->cy = srcSize.cy;
    pOutSize->cx = rcArrow.Width() + srcSize.cx;

    //POINT
    pOutPoint->x = srcPoint.x-pOutSize->cx;

    if (eCTTS_Align_Reverse == m_enumAlign)
        pOutPoint->y = srcPoint.y-pOutSize->cy;
    else
        pOutPoint->y = srcPoint.y;

    m_ptTextStart.x = 0;
    m_ptTextStart.y = 0;

    //REGION
    pOutRgn->CreateRoundRectRgn(0, 0, srcSize.cx + cs_nAdditionLen, srcSize.cy, cs_nRoundRect, cs_nRoundRect);

    if (eCTTS_Align_Reverse == m_enumAlign)
        rgnArrow.OffsetRgn(srcSize.cx, srcSize.cy-cs_nArrowPos-rcArrow.Height());
    else
        rgnArrow.OffsetRgn(srcSize.cx, cs_nArrowPos);
    pOutRgn->CombineRgn(*pOutRgn, rgnArrow, RGN_OR);
}


inline void CBkTips::GetArrowRgn(CustomTipsPos enumPos, CRgn * poutRgn)
{
    ATLASSERT(poutRgn != NULL);
    if (eCTTS_Style_arrow != (m_nStyle&eCTTS_Style_arrow))
    {
        poutRgn->CreateRectRgn(0, 0, 0, 0);
        return ;
    }
    CreateRgnFromPNG(m_strArrowPath, CPoint(0, 0), CSize(10, 7), 0, poutRgn);
    /*
    POINT * pts;
    POINT ptsTop[] = {{0, 0}, {10, 0}, {5, 14}};
    POINT ptsBottom[] = {{5, 0}, {0, 14}, {10, 14}};
    POINT ptsRight[] = {{0, 5}, {14, 0}, {14, 10}};
    POINT ptsLeft[] = {{0, 0}, {0, 10}, {14, 5}};

    switch(enumPos)
    {
    case  eCTTS_POS_Left:
    pts = ptsLeft;
    break;
    case  eCTTS_POS_Right:
    pts = ptsRight;
    break;
    case  eCTTS_POS_Bottom:
    pts = ptsBottom;
    break;
    case  eCTTS_POS_Top:
    pts = ptsTop;
    break;
    default:
    ATLASSERT(0);
    }
    //生成一个简单的区域

    poutRgn->CreatePolygonRgn(pts, 3, ALTERNATE);

    */
}

inline void CBkTips::SetArrowSize(SIZE sizeArrow)
{
    m_sizeArrow = sizeArrow;
}

inline void CBkTips::CreateRgnFromPNG(LPCWSTR szPNGName, POINT ptImage, SIZE sizeImage, BYTE byAlpha , CRgn* outRgn)
{
    using namespace Gdiplus;
    CClientDC dc(m_hWnd);
    Graphics g(dc.m_hDC);
    Bitmap bmp(szPNGName, FALSE);
    Color col;
    //outRgn->CreateFromPath
    outRgn->CreateRectRgn(ptImage.x, ptImage.y, ptImage.x + sizeImage.cx, ptImage.y + sizeImage.cy);
    for(int i = ptImage.x;i<sizeImage.cx;i++)
    {
        for(int j = ptImage.y;j<sizeImage.cy;j++)
        {
            bmp.GetPixel(i, j, &col);
            if (col.GetAlpha() <= byAlpha)
            {
                CRgn rgn;
                rgn.CreateRectRgn(i, j, i + 1, j + 1);
                outRgn->CombineRgn(*outRgn, rgn, RGN_XOR);
            }
        }
    }
}

inline void CBkTips::CopyRgn(CRgn& srcRgn, CRgn& desRgn)
{
    desRgn.CreateRectRgn(0, 0, 0, 0);
    desRgn.CombineRgn(srcRgn, NULL, RGN_COPY);
}

inline void CBkTips::InflateRgn(CRgn & srcRgn, CRgn & desRgn)
{
    CRgn rgnTop;
    CRgn rgnBottom;
    CRgn rgnLeft;
    CRgn rgnRight;
    ATLASSERT(desRgn.m_hRgn == NULL);
    desRgn.CreateRectRgn(0, 0, 0, 0);
    CopyRgn(srcRgn, rgnTop);
    CopyRgn(srcRgn, rgnBottom);
    CopyRgn(srcRgn, rgnLeft);
    CopyRgn(srcRgn, rgnRight);
    rgnTop.OffsetRgn(0, 1);
    rgnBottom.OffsetRgn(0, -1);
    rgnLeft.OffsetRgn(1, 0);
    rgnRight.OffsetRgn(-1, 0);
    rgnTop.CombineRgn(rgnTop, rgnBottom, RGN_AND);
    rgnLeft.CombineRgn(rgnLeft, rgnRight, RGN_AND);
    desRgn.CombineRgn(rgnTop, rgnLeft, RGN_AND);
}


inline CBkTips* CBkTips::GetTipObjFromHwnd(HWND hWnd)
{
    return (CBkTips*)GetProp(hWnd, szTipProp);
}

inline LRESULT CALLBACK CBkTips::TipParentProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    CBkTips* pTipObj = GetTipObjFromHwnd(hwnd);
    if (pTipObj != NULL)
    {
        return pTipObj->TipParentProcFilter(message, wParam, lParam);
    }
    return 0l;
}

inline LRESULT CBkTips::TipParentProcFilter(UINT message, WPARAM wParam, LPARAM lParam)
{    
    if (message == WM_LBUTTONDOWN
        || message == WM_COMMAND)
    {
        HideTips();
    }

    return CallWindowProc(m_ProcOld, m_hWnd, message, wParam, lParam);
}